ty Opaque = opaque

* Is needed because otherwise cunning LLVM will cut `Opaque` out
foo x: Opaque -> Opaque = extern

puts str: *u8 -> i32 = extern

pass = ()

* Sadly not smart enough to infer the type of the function on its own
fib n: u64 -> u64 = if n == 0 or n == 1 do 1 else (fib n - 1) + fib n - 2

identity x: i32 = x

drop x: [i32 x 4] = pass

* `as` is a special operator which works if the type has method `from` on it
* For example, `a as T` is equivalent to `T::from(a)`
* asPtr.& [i8 x 14] = i as *[i8 x 14] as *i8

* "Hallo".asPtr

add x y: u8 = x + y

* ************ *
* `copy` influences only move semantics, automatic cloning and dropping.
* It does NOT influence usages of `alloca` instruction to create the value!!!
* ************ *

ty Alias = alias Wrapper.InnerWrapper

ty IWrapper = alias Wrapper.InnerWrapper.VeryInner.IWrapper

ty int = alias i32
ty char = alias i8

ty VeryInner = opaque
    ty IWrapper = alias &Wrapper

    identity.* x: char = x

    twentySeven.* = 27

ty InnerWrapper = x y z w: char
    ty VeryInner = alias VeryInner

    getZ.* i: Y = Y.VeryInner.identity i.z

ty Wrapper
	x: int
	y: Alias
	z: (i32, i32)

	ty RefToWrapper = alias IWrapper

	ty InnerWrapper = alias InnerWrapper

	new.* i: Y.RefToWrapper = i

	unwrap.! = Y.InnerWrapper.getZ i.y

	test.* i: Y.RefToWrapper = (Y.new i).x

twentySeven = Alias.VeryInner.twentySeven

ty InnerWrapper2 = x: int

* An example from README.md
ty Wrapper2 = x: Y.InnerWrapper
    ty InnerWrapper = alias InnerWrapper2

    unwrap.& = i.x.x

test -> (i32, i32)
    $a := (identity 4), (identity 4)
    return a

ty bool = yes | no

doSmth x: bool = x

ty optional = None | Some i32
    ID.& = i
